//Стандартная библиотека шаблонов - STL 
	//Контейнеры стандартной библиотеки - vector
	//Итераторы

//#include <iostream>
//#include <vector>
#include "Header.h"
#include "MyString.h"
#include "Point.h"


#pragma warning(disable: 4786)


using namespace std;	

#define	  stop __asm nop
const char* sep = "------------------------------------\n";


int main()
{
	// Контейнер стандартной библиотеки vector 

//////////////////////////////////////////////////////////////////////
	//Создание векторов. 

	//Создайте следующие вектора:
	//---------------------------
	//пустой вектор целых чисел - vInt и проверьте с помощью функции size(),
	//что его размер нулевой. 
	vector<int> vInt;
	std::cout << vInt.size() << std::endl;

	//Раскомментируйте следующий фрагмент, подумайте - все ли корректно
	//Если есть некорректности, - исправьте

	if (!vInt.empty())
	{
		vInt.front() = 1;
	}
	else
	{
		std::cout << "Trying to access the first element of an empty vector" << std::endl;
	}
	std::cout << sep << std::endl;


	//С помощью функции push_back() в цикле заполните вектор какими-либо значениями.
	//На каждой итерации цикла следите за размером вектора с помощью методов
	//size(), capacity(), max_size() и выводите значения элементов. 
	//
	//Подсказка: так как такая проверка понадобится Вам и в следующих заданиях,
	//напишите шаблон функции, которая для вектора, содержащего элементы любого типа
	//выводит его "реквизиты" и значения элементов на консоль.
	for (size_t i = 0; i < 5; i++)
	{
		vInt.push_back(i);
		PrintVectorInfo(vInt);
	}
	std::cout << sep << std::endl;

	//вектор вещественных - vDouble1 с заданным Вами начальным размером  и
	//проверьте результат с помощью созданного Вами шаблона. Как будут
	//проинициализированы элементы вектора?

	vector<double> vDouble1(5); //элементы вектора проинициализированы конструктором по умолчанию, то есть 0.0
	PrintVectorInfo(vDouble1);
	std::cout << sep << std::endl;
	double Val = 1.1;
	for (size_t i = 0; i < 5; i++)
	{
		vDouble1.push_back(Val);
		PrintVectorInfo(vDouble1);
		Val += 1.1;
	}
	std::cout << sep << std::endl;

	//вектор объектов типа MyString с начальным размером - 5 элементов
	//и инициализацией каждого элемента строкой "A"
	//C помощью функции at() а также с помощью оператора
	//индексирования []  измените значения каких-либо элементов.
	//Попробуйте "выйти" за границы вектора с помощью at() и
	//с помощью []. 
	vector<MyString> vMyString(5, MyString("A"));
	PrintVectorInfo(vMyString);
	
	vMyString.at(0) = MyString("B");
	vMyString[0] = MyString("C");
	try
	{
		vMyString.at(5) = MyString("D");
	}
	catch (const std::out_of_range& e)
	{
		std::cout << "Exception caught (at()): "<< e.what() << std::endl;
	}
	std::cout << sep << std::endl;


	//вектор вещественных - vDouble3, который является копией элементов
	// [0,5) массива вещественных чисел dMas. Предварительно массив dMas 
	//нужно создать и проинициализировать!
#define DEBUG
	
#ifndef DEBUG
	double dMas[] = { 1.5,2.5,3.5,4.5,5.5,6.5 };
	int size = sizeof(dMas) / sizeof(dMas[0]);
	vector<double> vDouble3(dMas, dMas + size / 2);

	for (size_t i = 0; i < vDouble3.size(); i++)
	{
		std::cout << vDouble3[i] << " ";
	}
	std::cout << sep << std::endl;
#endif // !DEBUG

	
#ifdef DEBUG
	double dMas[] = { 1.5,2.5,3.5,4.5,5.5,6.5 };
	vector<double> vDouble3 = { dMas[0], dMas[5] };
	for (size_t i = 0; i < vDouble3.size(); i++)
	{
		std::cout << vDouble3[i] << " ";
	}
	std::cout << std::endl;
	std::cout << sep << std::endl;
#endif //DEBUG

	
	//вектор вещественных - vDouble4, который является копией элементов
	// [2,5) вектора vDouble3. 
	vDouble3.resize(5);
	vector<double> vDouble4 = { vDouble3[1], vDouble3[4] };
	
	for (size_t i = 0; i < vDouble4.size(); i++)
	{
		std::cout << vDouble3[i] << " ";
	}
	std::cout << std::endl;
	std::cout << sep << std::endl;

	//вектор элементов типа Point - vPoint1 а) с начальным размером 3. Какой конструктор
	//будет вызван для каждого элемента?
	//b) vPoint2 с начальным размером 5 и проинициализируйте каждый элемент координатами (1,1).
	
	vector<Point> vPoint1(3);												//Для каждого элемента вызван конструктор по умолчанию
	vector<Point> vPoint2(5, Point(1, 1));									//Сначала будет ызван конструктор с параметрами, остальные четыре значения сформируются сгенерированным автоматически компилятором конструтором копирования
	
	//вектор указателей на Point - vpPoint с начальным размером 5
	//Подумайте: как корректно заставить эти указатели "указывать" на объекты Point
	{
		vector<Point*>vpPoint1(5);
		for (size_t i = 0; i < vpPoint1.size(); i++)
		{
			vpPoint1[i] = &vPoint2[i];
		}
		vector<Point*>vpPoint2(5);
		for (size_t i = 0; i < vpPoint1.size(); i++)
		{
			vpPoint2[i] = new Point(1, 1);
		}
		
	//Подсказка: для вывода на печать значений скорее всего Вам понадобится
		//а) специализация Вашей шаблонной функции
		//б) или перегрузка operator<< для Point*
		std::cout << vpPoint1[0];											//выводим на консоль первый элемент вектора
		std::cout << sep << std::endl;					
		
		std::cout << vpPoint1;												//выводим в консоль весь вектор с помощью перегруженного оператора<<
		std::cout << sep << std::endl;										//выводим в консоль весь вектор с помощью специализированного шаблона функции

		PrintVectorInfo(vpPoint2);

		for (size_t i = 0; i < vpPoint2.size(); i++)
		{
			delete vpPoint2[i];												//Для vpPoint2 освобождвем память
		}
	}																		//По закрывающей скобке автоматически вызовется деструктор для vpPoint1
	//Какие дополнительные действия нужно предпринять для такого вектора?


	///////////////////////////////////////////////////////////////////////
	//Резервирование памяти.
	//Подумайте, всегда ли верны приведенные ниже проверки?
		
		{
		size_t n = 5;
		vector<int> v(n);								//создаем вектор интов с размером 5 элементов
		v.resize(n/2);									//изменяем размер вектора
			if (v.capacity() == n)  //true?				//так так n/2<capacity, перераспределения памяти не происходит, условие true
			{
				std::cout << "#1 " << std::endl;
			}
			
		}
		

		
		{
		int n = 5;										
		size_t m = 10;
		vector<int> v(n);								//создаем вектор интов с размером 5 элементов
		v.reserve(m);									//резервируем память под 10 элементов, фактический размер не меняется
		if(v.capacity() == m) //true?					//условие всегда true, даже если n>m
			{
				std::cout << "#2 " << std::endl;
			}
		}
		

		
		{
		vector<int> v(3,5);								//создаем вектор интов с размером 3 и инициализируем элементы 5-ками							[5,5,5]
		v.resize(4,10); //значения?						//изменяем размер вектора до 4-х и инициализируем последний элемент 10							[5,5,5,10]
		v.resize(5); //значения?						//изменяем размер вектора до 5-и и инициализируем последний элемент дефолтовым конструктором	[5,5,5,10,0]
	
		}
		

	//Создайте два "пустых" вектора с элементами
	//любого (но одного и того же типа) типа. 
		{
			vector<int> vInt1;
			vector<int>vInt2;


		//В первом векторе зарезервируйте память под 5 элементов, а потом заполните
		//его значениями с помощью push_back.
		vInt1.reserve(5);														//size=0;capacity=5;
		for (size_t i = 0; i < vInt1.capacity(); i++)
		{
			vInt1.push_back(i);													//в цикле заполняем вектор, size1>>2>>3>>4>>5;capacity=5;
			PrintVectorInfo(vInt1);
		}
		std::cout << sep << std::endl;
		//Второй вектор просто заполните значениями посредством push_back.
		for (size_t i = 0; i < 5; i++)											//size=0;capacity=0;
		{
			vInt2.push_back(i);													//в цикле заполняем веткор с перераспределением памяти 
			PrintVectorInfo(vInt2);												//size1>>2>>3>>4>>4; capacity1>>2>>3>>4>>6
		}
		std::cout << sep << std::endl;
		//Сравните размер, емкость векторов и значения элементов


		//!!! shrink_to_fit - Уменьшение емкости вектора.
		//Для любого вектора из предыдущего задания требуется уменьшить емкость
		//до size.
		vInt1.shrink_to_fit();
		vInt2.shrink_to_fit();

		}
	//Создание "двухмерного вектора" - вектора векторов
	//Задан одномерный массив int ar[] = {11,2,4,3,5};
	//Создайте вектор векторов следующим образом:
	//вектор vv[0] - содержит 11 элементов со значением 11
	//vv[1] - содержит 2,2
	//vv[2] - содержит 4,4,4,4
	//...
		int ar[] = { 11,2,4,3,5 };
		vector<vector<int>> vv(5);
		for (size_t i = 0; i < sizeof(ar)/sizeof(ar[0]); i++)
		{
			vv[i].assign(ar[i], ar[i]);
		}
	//Распечатайте содержимое такого двухмерного вектора по строкам
	//с помощью:
	
	std::cout<<vv<<std::endl;
	std::cout << sep << std::endl;
	stop

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//Вставка элемента последовательности insert().
	//Реализуйте функцию, которая должна вставлять новый элемент
	//в начало вектора только при условии, что в векторе такого
	//значения еще нет.
	//Проверьте работоспособность функции - в вектор vChar2 вставьте в начало вектора символ только при
	//условии, что в векторе такого символа еще нет.
	//например: vChar2 - abc 
	//При попытке вставить 'a' попытка должна быть проигнорирована
	//При попытке вставить 'q' vChar2 - qabc 

	vector<char> vChar2 = { 'a','b','c' };
	bool pruf=InsertElementChar(vChar2, 'd');
	
	
	//Реализуйте функцию, которая должна вставлять новый элемент
	//перед каждым элементом вектора
	//Проверьте работоспособность функции - вставьте перед каждым элементом вектора vChar2 букву 'W'
	
	InsertElementW(vChar2);

///////////////////////////////////////////////////////////////////
	//Напишите функцию, которая должна удалять только повторяющиеся последовательности.
	//Например: было - "qwerrrrty12222r3", стало - "qwety1r3"

	vector<char> vChar3 = { 'q','w','e','r','r','r','r','t','y','1','2','2','2','2','r','3' };
	vector<char> vChar4 = { 'q','w','e','r','r','r','r','t','y','1','2','2','2','2','r','3' };
	EraseRepeat(vChar3);
	RemoveDuplicateSequences(vChar4);



	stop

///////////////////////////////////////////////////////////////////

	//Удаление элемента последовательности erase()
	//Напишите функцию удаления из любого вектора всех дублей 
		 //Например: было - "qwerrrrty12222r3", стало - "qwerty123"



	

///////////////////////////////////////////////////////////////////
	//Создайте новый вектор таким образом, чтобы его элементы стали
	//копиями элементов любого из созданных ранее векторов, но расположены
	//были бы в обратном порядке






///////////////////////////////////////////////////////////////////

	//Задание 1. Списки. Операции, характерные для списков.
	//Создайте пустой список из элементов Point - ptList1 и наполните
	//его значениями с помощью методов push_back(),
	//push_front, insert()
	

	//Напишите шаблон функции, которая будет выводить элементы
	//ЛЮБОГО КОНТЕЙНЕРА на печать. Проверьте работу шаблона на контейнерах
	//vector и list. Подсказка - хотелось бы увидеть тип контейнера.


	//Сделайте любой из списков "реверсивным" - reverse()


	//Создайте список ptList2 из элементов Point таким образом, чтобы он стал 
	//копией вектора элементов типа Point, но значения элементов списка располагались
	//бы в обратном порядке 



	//Отсортируйте списки  ptList1 и ptList2 - методом класса list - sort()
	//по возрастанию.
	//Подумайте: что должно быть перегружено в классе Point для того, чтобы
	//работала сортировка


	


	stop

	//Объедините отсортированные списки - merge(). Посмотрите: что
	//при этом происходит с каждым списком.

	
	stop

	//Исключение элемента из списка - remove()
	//Исключите из списка элемент с определенным значением.
	//Подумайте: что должно быть перегружено в классе Point?
	

	//Исключение элемента из списка, удовлетворяющего заданному условию:
	//любая из координат отрицательна - remove_if(). 


	//Исключение из списка подряд расположенных дублей - unique(). 

	stop

///////////////////////////////////////////////////////////////////
	//Задание 2.Очередь с двумя концами - контейнер deque

	//Создайте пустой deque с элементами типа Point. С помощью
	//assign заполните deque копиями элементов вектора. С помощью
	//разработанного Вами в предыдущем задании универсального шаблона
	//выведите значения элементов на печать



	//Создайте deque с элементами типа MyString. Заполните его значениями
	//с помощью push_back(), push_front(), insert()
	//С помощью erase удалите из deque все элементы, в которых строчки
	//начинаются с 'A' или 'a'




	return 0;
}